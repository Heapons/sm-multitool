public Action Command_SetClass(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to set their class.");
		return Plugin_Handled;
	}
	else if (args == 1)
	{
		SendPrint(client, "You must specify a class to set.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	char sClass[32];
	GetCmdArg(2, sClass, sizeof(sClass));
	TFClassType class = IsStringNumeric(sClass) ? view_as<TFClassType>(StringToInt(sClass)) : TF2_GetClass(sClass);

	if (class == TFClass_Unknown)
	{
		SendPrint(client, "You have specified an invalid class.");
		return Plugin_Handled;
	}

	char sClassName[32];
	TF2_GetClassName(class, sClassName, sizeof(sClassName));

	for (int i = 0; i < targets; i++)
	{
		TF2_SetPlayerClass(targets_list[i], class, false, true);
		TF2_RegeneratePlayer(targets_list[i]);
		SendPrint(targets_list[i], "Your class has been set to [H]%s [D]by [H]%N [D].", sClassName, client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have set the class of [H]%t [D]to [H]%s [D].", sTargetName, sClassName);
	else
		SendPrint(client, "You have set the class of [H]%s [D]to [H]%s [D].", sTargetName, sClassName);

	return Plugin_Handled;
}

public Action Command_Regenerate(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to regenerate.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	for (int i = 0; i < targets; i++)
	{
		TF2_RegeneratePlayer(targets_list[i]);
		SendPrint(targets_list[i], "Your have been regenerated by [H]%N [D].", client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have regenerated [H]%t [D].", sTargetName);
	else
		SendPrint(client, "You have regenerated [H]%s [D].", sTargetName);

	return Plugin_Handled;
}

public Action Command_SetCondition(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to add a condition to.");
		return Plugin_Handled;
	}
	else if (args == 1)
	{
		SendPrint(client, "You must specify a condition to set.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	char sCondition[12];
	GetCmdArg(2, sCondition, sizeof(sCondition));
	TFCond condition = view_as<TFCond>(StringToInt(sCondition));

	if (view_as<int>(condition) < 0 || view_as<int>(condition) > 118)
	{
		SendPrint(client, "You have specified an invalid condition.");
		return Plugin_Handled;
	}

	float time = TFCondDuration_Infinite;

	if (args >= 2)
	{
		char sTime[12];
		GetCmdArg(3, sTime, sizeof(sTime));

		time = StringToFloat(sTime);

		if (time < TFCondDuration_Infinite)
		{
			SendPrint(client, "You have specified an invalid time.");
			return Plugin_Handled;
		}
	}

	for (int i = 0; i < targets; i++)
	{
		TF2_AddCondition(targets_list[i], condition, time, client);
		SendPrint(targets_list[i], "Your have gained a new condition from [H]%N [D]for %.2f seconds.", client, time);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have set a new condition on [H]%t [D]for %.2f seconds.", sTargetName, time);
	else
		SendPrint(client, "You have set a new condition on [H]%s [D]for %.2f seconds.", sTargetName, time);

	return Plugin_Handled;
}

public Action Command_RemoveCondition(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to remove a condition from.");
		return Plugin_Handled;
	}
	else if (args == 1)
	{
		SendPrint(client, "You must specify a condition to remove.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	char sCondition[12];
	GetCmdArg(2, sCondition, sizeof(sCondition));
	TFCond condition = view_as<TFCond>(StringToInt(sCondition));

	if (view_as<int>(condition) < 0 || view_as<int>(condition) > 118)
	{
		SendPrint(client, "You have specified an invalid condition.");
		return Plugin_Handled;
	}

	for (int i = 0; i < targets; i++)
	{
		if (TF2_IsPlayerInCondition(targets_list[i], condition))
			continue;

		TF2_RemoveCondition(targets_list[i], condition);
		SendPrint(targets_list[i], "Your have been stripped of a condition by [H]%N [D].", client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have been stripped of a condition by [H]%t [D].", sTargetName);
	else
		SendPrint(client, "You have been stripped of a condition by [H]%s [D].", sTargetName);

	return Plugin_Handled;
}

public Action Command_SpewConditions(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}
	
	g_SpewConditions = !g_SpewConditions;
	SendPrint(client, "Spew Conditions: [H]%s [D]", g_SpewConditions ? "ON" : "OFF");
	return Plugin_Handled;
}

public Action Command_SetUbercharge(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to set their ubercharge.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	char sUbercharge[12];
	GetCmdArg(2, sUbercharge, sizeof(sUbercharge));
	float uber = ClampCell(StringToFloat(sUbercharge), 0.0, 999999.0);

	for (int i = 0; i < targets; i++)
	{
		if (TF2_GetPlayerClass(targets_list[i]) != TFClass_Medic)
			continue;

		TF2_SetUberLevel(targets_list[i], uber);
		SendPrint(targets_list[i], "Your ubercharge has been set to %.2f by [H]%N [D].", uber, client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have set the ubercharge of [H]%t [D]to %.2f.", sTargetName, uber);
	else
		SendPrint(client, "You have set the ubercharge of [H]%s [D]to %.2f.", sTargetName, uber);

	return Plugin_Handled;
}

public Action Command_AddUbercharge(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to add to their ubercharge.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	char sUbercharge[12];
	GetCmdArg(2, sUbercharge, sizeof(sUbercharge));
	float uber = ClampCell(StringToFloat(sUbercharge), 0.0, 999999.0);

	for (int i = 0; i < targets; i++)
	{
		if (TF2_GetPlayerClass(targets_list[i]) != TFClass_Medic)
			continue;

		TF2_AddUberLevel(targets_list[i], uber);
		SendPrint(targets_list[i], "Your ubercharge has been increased by %.2f by [H]%N [D].", uber, client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have increased the ubercharge of [H]%t [D]by %.2f.", sTargetName, uber);
	else
		SendPrint(client, "You have increased the ubercharge of [H]%s [D]by %.2f.", sTargetName, uber);

	return Plugin_Handled;
}

public Action Command_RemoveUbercharge(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to deduct from their ubercharge.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	char sUbercharge[12];
	GetCmdArg(2, sUbercharge, sizeof(sUbercharge));
	float uber = ClampCell(StringToFloat(sUbercharge), 0.0, 999999.0);

	for (int i = 0; i < targets; i++)
	{
		if (TF2_GetPlayerClass(targets_list[i]) != TFClass_Medic)
			continue;

		TF2_RemoveUberLevel(targets_list[i], uber);
		SendPrint(targets_list[i], "Your ubercharge has been deducted by %.2f by [H]%N [D].", uber, client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have deducted ubercharge of [H]%t [D]by %.2f.", sTargetName, uber);
	else
		SendPrint(client, "You have deducted ubercharge of [H]%s [D]by %.2f.", sTargetName, uber);

	return Plugin_Handled;
}

public Action Command_SetMetal(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to set their metal.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	char sMetal[12];
	GetCmdArg(2, sMetal, sizeof(sMetal));
	int metal = ClampCell(StringToInt(sMetal), 1, 999999);

	for (int i = 0; i < targets; i++)
	{
		if (TF2_GetPlayerClass(targets_list[i]) != TFClass_Engineer)
			continue;

		TF2_SetMetal(targets_list[i], metal);
		SendPrint(targets_list[i], "Your metal has been set to [H]%i [D]by [H]%N [D].", metal, client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have set the metal of [H]%t [D]to [H]%i [D].", sTargetName, metal);
	else
		SendPrint(client, "You have set the metal of [H]%s [D]to [H]%i [D].", sTargetName, metal);

	return Plugin_Handled;
}

public Action Command_AddMetal(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to add to their metal.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	char sMetal[12];
	GetCmdArg(2, sMetal, sizeof(sMetal));
	int metal = ClampCell(StringToInt(sMetal), 1, 999999);

	for (int i = 0; i < targets; i++)
	{
		if (TF2_GetPlayerClass(targets_list[i]) != TFClass_Engineer)
			continue;

		TF2_AddMetal(targets_list[i], metal);
		SendPrint(targets_list[i], "Your metal has been increased by [H]%i [D]by [H]%N [D].", metal, client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have increased the metal of [H]%t [D]by [H]%i [D].", sTargetName, metal);
	else
		SendPrint(client, "You have increased the metal of [H]%s [D]by [H]%i [D].", sTargetName, metal);

	return Plugin_Handled;
}

public Action Command_RemoveMetal(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to deduct from their metal.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	char sMetal[12];
	GetCmdArg(2, sMetal, sizeof(sMetal));
	int metal = ClampCell(StringToInt(sMetal), 1, 999999);

	for (int i = 0; i < targets; i++)
	{
		if (TF2_GetPlayerClass(targets_list[i]) != TFClass_Engineer)
			continue;

		TF2_RemoveMetal(targets_list[i], metal);
		SendPrint(targets_list[i], "Your metal has been deducted by [H]%i [D]by [H]%N [D].", metal, client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have deducted metal of [H]%t [D]by [H]%i [D].", sTargetName, metal);
	else
		SendPrint(client, "You have deducted metal of [H]%s [D]by [H]%i [D].", sTargetName, metal);

	return Plugin_Handled;
}

public Action Command_GetMetal(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to see their metal amount.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}
	
	int target = GetCmdArgTarget(client, 1, false, false);
	
	if (target == -1)
	{
		SendPrint(client, "Target not found, please try again.");
		return Plugin_Handled;
	}
	
	if (TF2_GetPlayerClass(target) != TFClass_Engineer)
	{
		SendPrint(client, "[H]%N [D]is not an engineer.", target);
		return Plugin_Handled;
	}

	SendPrint(client, "[H]%N[D]'s metal amount is: [H]%i[D]", target, TF2_GetMetal(target));
	
	return Plugin_Handled;
}

public Action Command_SetCrits(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}

	if (args == 0)
	{
		SendPrint(client, "You must specify a target to set crits on.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	float time = TFCondDuration_Infinite;

	if (args >= 1)
	{
		char sTime[12];
		GetCmdArg(2, sTime, sizeof(sTime));

		time = StringToFloat(sTime);

		if (time < TFCondDuration_Infinite)
		{
			SendPrint(client, "You have specified an invalid time.");
			return Plugin_Handled;
		}
	}

	for (int i = 0; i < targets; i++)
	{
		TF2_AddCondition(targets_list[i], TFCond_CritOnWin, time, client);
		SendPrint(targets_list[i], "Your have gained crits from [H]%N [D]for %.2f seconds.", client, time);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have set crits on [H]%t [D]for %.2f seconds.", sTargetName, time);
	else
		SendPrint(client, "You have set crits on [H]%s [D]for %.2f seconds.", sTargetName, time);

	return Plugin_Handled;
}

public Action Command_RemoveCrits(int client, int args)
{
	if (!IsEnabled()) {
		return Plugin_Continue;
	}
	
	if (args == 0)
	{
		SendPrint(client, "You must specify a target to remove crits from.");
		return Plugin_Handled;
	}
	else if (game != Engine_TF2)
	{
		SendPrint(client, "This command is for Team Fortress 2 only.");
		return Plugin_Handled;
	}

	char sTarget[MAX_TARGET_LENGTH];
	GetCmdArg(1, sTarget, sizeof(sTarget));

	int targets_list[MAXPLAYERS];
	char sTargetName[MAX_TARGET_LENGTH];
	bool tn_is_ml;

	int targets = ProcessTargetString(sTarget, client, targets_list, sizeof(targets_list), COMMAND_FILTER_ALIVE, sTargetName, sizeof(sTargetName), tn_is_ml);

	if (targets <= 0)
	{
		ReplyToTargetError(client, COMMAND_TARGET_NONE);
		return Plugin_Handled;
	}

	for (int i = 0; i < targets; i++)
	{
		if (TF2_IsPlayerInCondition(targets_list[i], TFCond_CritOnWin))
			continue;

		TF2_RemoveCondition(targets_list[i], TFCond_CritOnWin);
		SendPrint(targets_list[i], "Your have been stripped of crits by [H]%N [D].", client);
	}
	
	if (tn_is_ml)
		SendPrint(client, "You have stripped crits from [H]%t [D].", sTargetName);
	else
		SendPrint(client, "You have stripped crits from [H]%s [D].", sTargetName);

	return Plugin_Handled;
}